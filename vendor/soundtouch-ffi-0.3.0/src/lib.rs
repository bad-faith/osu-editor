/* automatically generated by rust-bindgen 0.71.1 */


#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub use root::{soundtouch::*, TDStretch, uint};


#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[doc = r" If Bindgen could only determine the size and alignment of a"]
    #[doc = r" type, it is represented like this."]
    #[derive(PartialEq, Copy, Clone, Debug, Hash)]
    #[repr(C)]
    pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
    impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
        fn default() -> Self {
            Self([<T as Default>::default(); N])
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__From_primary = u8;
        pub type allocator_value_type = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Alty = u8;
        pub type vector__Alty_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector__Scary_val = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__Reallocation_guard {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__Simple_reallocation_guard {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__Vaporization_guard {
            pub _address: u8,
        }
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub const vector__Reallocation_policy__At_least: root::std::vector__Reallocation_policy = 0;
        pub const vector__Reallocation_policy__Exactly: root::std::vector__Reallocation_policy = 0;
        pub type vector__Reallocation_policy = ::core::ffi::c_int;
    }
    pub type uint = ::core::ffi::c_uint;
    pub mod soundtouch {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type SAMPLETYPE = f32;
        pub type LONG_SAMPLETYPE = f32;
        #[repr(C)]
        pub struct FIFOSamplePipe__bindgen_vtable(::core::ffi::c_void);
        #[doc = " Abstract base class for FIFO (first-in-first-out) sample processing classes."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSamplePipe {
            pub vtable_: *const FIFOSamplePipe__bindgen_vtable,
        }
        #[doc = " Base-class for sound processing routines working in FIFO principle. With this base\n class it's easy to implement sound processing stages that can be chained together,\n so that samples that are fed into beginning of the pipe automatically go through\n all the processing stages.\n\n When samples are input to this class, they're first processed and then put to\n the FIFO pipe that's defined as output of this class. This output pipe can be\n either other processing stage or a FIFO sample buffer."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOProcessor {
            pub _base: root::soundtouch::FIFOSamplePipe,
            #[doc = " Internal pipe where processed samples are put."]
            pub output: *mut root::soundtouch::FIFOSamplePipe,
        }
        #[doc = " Sample buffer working in FIFO (first-in-first-out) principle. The class takes\n care of storage size adjustment and data moving during input/output operations.\n\n Notice that in case of stereo audio, one sample is considered to consist of\n both channel data."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSampleBuffer {
            pub _base: root::soundtouch::FIFOSamplePipe,
            #[doc = " Sample buffer."]
            pub buffer: *mut root::soundtouch::SAMPLETYPE,
            pub bufferUnaligned: *mut root::soundtouch::SAMPLETYPE,
            #[doc = " Sample buffer size in bytes"]
            pub sizeInBytes: root::uint,
            #[doc = " How many samples are currently in buffer."]
            pub samplesInBuffer: root::uint,
            #[doc = " Channels, 1=mono, 2=stereo."]
            pub channels: root::uint,
            #[doc = " Current position pointer to the buffer. This pointer is increased when samples are\n removed from the pipe so that it's necessary to actually rewind buffer (move data)\n only new data when is put to the pipe."]
            pub bufferPos: root::uint,
        }
        unsafe extern "C" {
            #[doc = " Returns a pointer to the end of the used part of the sample buffer (i.e.\n where the new samples are to be inserted). This function may be used for\n inserting new samples into the sample buffer directly. Please be careful\n not corrupt the book-keeping!\n\n When using this function as means for inserting new samples, also remember\n to increase the sample count afterwards, by calling  the\n 'putSamples(numSamples)' function."]
            #[link_name = "\u{1}?ptrEnd@FIFOSampleBuffer@soundtouch@@QEAAPEAMI@Z"]
            pub fn FIFOSampleBuffer_ptrEnd(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        unsafe extern "C" {
            #[doc = " Sets number of channels, 1 = mono, 2 = stereo."]
            #[link_name = "\u{1}?setChannels@FIFOSampleBuffer@soundtouch@@QEAAXH@Z"]
            pub fn FIFOSampleBuffer_setChannels(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[doc = " Add silence to end of buffer"]
            #[link_name = "\u{1}?addSilent@FIFOSampleBuffer@soundtouch@@QEAAXI@Z"]
            pub fn FIFOSampleBuffer_addSilent(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                nSamples: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Constructor"]
            #[link_name = "\u{1}??0FIFOSampleBuffer@soundtouch@@QEAA@H@Z"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: ::core::ffi::c_int,
            );
        }
        impl FIFOSampleBuffer {
            #[inline]
            pub unsafe fn ptrEnd(
                &mut self,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE {
                FIFOSampleBuffer_ptrEnd(self, slackCapacity)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: ::core::ffi::c_int) {
                FIFOSampleBuffer_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn addSilent(&mut self, nSamples: root::uint) {
                FIFOSampleBuffer_addSilent(self, nSamples)
            }
            #[inline]
            pub unsafe fn new(numChannels: ::core::ffi::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                FIFOSampleBuffer_FIFOSampleBuffer(__bindgen_tmp.as_mut_ptr(), numChannels);
                __bindgen_tmp.assume_init()
            }
        }
        unsafe extern "C" {
            #[doc = " destructor"]
            #[link_name = "\u{1}??1FIFOSampleBuffer@soundtouch@@UEAA@XZ"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer_destructor(
                this: *mut root::soundtouch::FIFOSampleBuffer,
            );
        }
        unsafe extern "C" {
            #[doc = " Returns a pointer to the beginning of the output samples.\n This function is provided for accessing the output samples directly.\n Please be careful for not to corrupt the book-keeping!\n\n When using this function to output samples, also remember to 'remove' the\n output samples from the buffer by calling the\n 'receiveSamples(numSamples)' function"]
            #[link_name = "\u{1}?ptrBegin@FIFOSampleBuffer@soundtouch@@UEAAPEAMXZ"]
            pub fn FIFOSampleBuffer_ptrBegin(
                this: *mut ::core::ffi::c_void,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        unsafe extern "C" {
            #[doc = " Adds 'numSamples' pcs of samples from the 'samples' memory position to\n the sample buffer."]
            #[link_name = "\u{1}?putSamples@FIFOSampleBuffer@soundtouch@@UEAAXPEBMI@Z"]
            pub fn FIFOSampleBuffer_putSamples(
                this: *mut ::core::ffi::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Adjusts the book-keeping to increase number of samples in the buffer without\n copying any actual samples.\n\n This function is used to update the number of samples in the sample buffer\n when accessing the buffer directly with 'ptrEnd' function. Please be\n careful though!"]
            #[link_name = "\u{1}?putSamples@FIFOSampleBuffer@soundtouch@@UEAAXI@Z"]
            pub fn FIFOSampleBuffer_putSamples1(
                this: *mut ::core::ffi::c_void,
                numSamples: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Output samples from beginning of the sample buffer. Copies requested samples to\n output buffer and removes them from the sample buffer. If there are less than\n 'numsample' samples in the buffer, returns all that available.\n\n \\return Number of samples returned."]
            #[link_name = "\u{1}?receiveSamples@FIFOSampleBuffer@soundtouch@@UEAAIPEAMI@Z"]
            pub fn FIFOSampleBuffer_receiveSamples(
                this: *mut ::core::ffi::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Adjusts book-keeping so that given number of samples are removed from beginning of the\n sample buffer without copying them anywhere.\n\n Used to reduce the number of samples in the buffer when accessing the sample buffer directly\n with 'ptrBegin' function."]
            #[link_name = "\u{1}?receiveSamples@FIFOSampleBuffer@soundtouch@@UEAAII@Z"]
            pub fn FIFOSampleBuffer_receiveSamples1(
                this: *mut ::core::ffi::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Returns number of samples currently available."]
            #[link_name = "\u{1}?numSamples@FIFOSampleBuffer@soundtouch@@UEBAIXZ"]
            pub fn FIFOSampleBuffer_numSamples(this: *mut ::core::ffi::c_void) -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Returns nonzero if there aren't any samples available for outputting."]
            #[link_name = "\u{1}?isEmpty@FIFOSampleBuffer@soundtouch@@UEBAHXZ"]
            pub fn FIFOSampleBuffer_isEmpty(this: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
        }
        unsafe extern "C" {
            #[doc = " Clears all the samples."]
            #[link_name = "\u{1}?clear@FIFOSampleBuffer@soundtouch@@UEAAXXZ"]
            pub fn FIFOSampleBuffer_clear(this: *mut ::core::ffi::c_void);
        }
        unsafe extern "C" {
            #[doc = " allow trimming (downwards) amount of samples in pipeline.\n Returns adjusted amount of samples"]
            #[link_name = "\u{1}?adjustAmountOfSamples@FIFOSampleBuffer@soundtouch@@UEAAII@Z"]
            pub fn FIFOSampleBuffer_adjustAmountOfSamples(
                this: *mut ::core::ffi::c_void,
                numSamples: root::uint,
            ) -> root::uint;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BEAT {
            pub pos: f32,
            pub strength: f32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IIR2_filter {
            pub coeffs: [f64; 5usize],
            pub prev: [f64; 5usize],
        }
        unsafe extern "C" {
            #[link_name = "\u{1}?update@IIR2_filter@soundtouch@@QEAAMM@Z"]
            pub fn IIR2_filter_update(this: *mut root::soundtouch::IIR2_filter, x: f32) -> f32;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}??0IIR2_filter@soundtouch@@QEAA@PEBN@Z"]
            pub fn IIR2_filter_IIR2_filter(
                this: *mut root::soundtouch::IIR2_filter,
                lpf_coeffs: *const f64,
            );
        }
        impl IIR2_filter {
            #[inline]
            pub unsafe fn update(&mut self, x: f32) -> f32 {
                IIR2_filter_update(self, x)
            }
            #[inline]
            pub unsafe fn new(lpf_coeffs: *const f64) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                IIR2_filter_IIR2_filter(__bindgen_tmp.as_mut_ptr(), lpf_coeffs);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct BPMDetect__bindgen_vtable(::core::ffi::c_void);
        #[doc = " Class for calculating BPM rate for audio data."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct BPMDetect {
            pub vtable_: *const BPMDetect__bindgen_vtable,
            #[doc = " Auto-correlation accumulator bins."]
            pub xcorr: *mut f32,
            #[doc = " Sample average counter."]
            pub decimateCount: ::core::ffi::c_int,
            #[doc = " Sample average accumulator for FIFO-like decimation."]
            pub decimateSum: root::soundtouch::LONG_SAMPLETYPE,
            #[doc = " Decimate sound by this coefficient to reach approx. 500 Hz."]
            pub decimateBy: ::core::ffi::c_int,
            #[doc = " Auto-correlation window length"]
            pub windowLen: ::core::ffi::c_int,
            #[doc = " Number of channels (1 = mono, 2 = stereo)"]
            pub channels: ::core::ffi::c_int,
            #[doc = " sample rate"]
            pub sampleRate: ::core::ffi::c_int,
            #[doc = " Beginning of auto-correlation window: Autocorrelation isn't being updated for\n the first these many correlation bins."]
            pub windowStart: ::core::ffi::c_int,
            #[doc = " window functions for data preconditioning"]
            pub hamw: *mut f32,
            pub hamw2: *mut f32,
            pub pos: ::core::ffi::c_int,
            pub peakPos: ::core::ffi::c_int,
            pub beatcorr_ringbuffpos: ::core::ffi::c_int,
            pub init_scaler: ::core::ffi::c_int,
            pub peakVal: f32,
            pub beatcorr_ringbuff: *mut f32,
            #[doc = " FIFO-buffer for decimated processing samples."]
            pub buffer: *mut root::soundtouch::FIFOSampleBuffer,
            pub beats: root::__BindgenOpaqueArray<u64, 3usize>,
            pub beat_lpf: root::soundtouch::IIR2_filter,
        }
        unsafe extern "C" {
            #[doc = " Updates auto-correlation function for given number of decimated samples that\n are read from the internal 'buffer' pipe (samples aren't removed from the pipe\n though)."]
            #[link_name = "\u{1}?updateXCorr@BPMDetect@soundtouch@@IEAAXH@Z"]
            pub fn BPMDetect_updateXCorr(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[doc = " Decimates samples to approx. 500 Hz.\n\n \\return Number of output samples."]
            #[link_name = "\u{1}?decimate@BPMDetect@soundtouch@@IEAAHPEAMPEBMH@Z"]
            pub fn BPMDetect_decimate(
                this: *mut root::soundtouch::BPMDetect,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int;
        }
        unsafe extern "C" {
            #[doc = " Calculates amplitude envelope for the buffer of samples.\n Result is output to 'samples'."]
            #[link_name = "\u{1}?calcEnvelope@BPMDetect@soundtouch@@IEAAXPEAMH@Z"]
            pub fn BPMDetect_calcEnvelope(
                this: *mut root::soundtouch::BPMDetect,
                samples: *mut root::soundtouch::SAMPLETYPE,
                numsamples: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[doc = " remove constant bias from xcorr data"]
            #[link_name = "\u{1}?removeBias@BPMDetect@soundtouch@@IEAAXXZ"]
            pub fn BPMDetect_removeBias(this: *mut root::soundtouch::BPMDetect);
        }
        unsafe extern "C" {
            #[link_name = "\u{1}?updateBeatPos@BPMDetect@soundtouch@@IEAAXH@Z"]
            pub fn BPMDetect_updateBeatPos(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[doc = " Inputs a block of samples for analyzing: Envelopes the samples and then\n updates the autocorrelation estimation. When whole song data has been input\n in smaller blocks using this function, read the resulting bpm with 'getBpm'\n function.\n\n Notice that data in 'samples' array can be disrupted in processing."]
            #[link_name = "\u{1}?inputSamples@BPMDetect@soundtouch@@QEAAXPEBMH@Z"]
            pub fn BPMDetect_inputSamples(
                this: *mut root::soundtouch::BPMDetect,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[doc = " Analyzes the results and returns the BPM rate. Use this function to read result\n after whole song data has been input to the class by consecutive calls of\n 'inputSamples' function.\n\n \\return Beats-per-minute rate, or zero if detection failed."]
            #[link_name = "\u{1}?getBpm@BPMDetect@soundtouch@@QEAAMXZ"]
            pub fn BPMDetect_getBpm(this: *mut root::soundtouch::BPMDetect) -> f32;
        }
        unsafe extern "C" {
            #[doc = " Get beat position arrays. Note: The array includes also really low beat detection values\n in absence of clear strong beats. Consumer may wish to filter low values away.\n - \"pos\" receive array of beat positions\n - \"values\" receive array of beat detection strengths\n - max_num indicates max.size of \"pos\" and \"values\" array.\n\n You can query a suitable array sized by calling this with NULL in \"pos\" & \"values\".\n\n \\return number of beats in the arrays."]
            #[link_name = "\u{1}?getBeats@BPMDetect@soundtouch@@QEAAHPEAM0H@Z"]
            pub fn BPMDetect_getBeats(
                this: *mut root::soundtouch::BPMDetect,
                pos: *mut f32,
                strength: *mut f32,
                max_num: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int;
        }
        unsafe extern "C" {
            #[doc = " Constructor."]
            #[link_name = "\u{1}??0BPMDetect@soundtouch@@QEAA@HH@Z"]
            pub fn BPMDetect_BPMDetect(
                this: *mut root::soundtouch::BPMDetect,
                numChannels: ::core::ffi::c_int,
                sampleRate: ::core::ffi::c_int,
            );
        }
        impl BPMDetect {
            #[inline]
            pub unsafe fn updateXCorr(&mut self, process_samples: ::core::ffi::c_int) {
                BPMDetect_updateXCorr(self, process_samples)
            }
            #[inline]
            pub unsafe fn decimate(
                &mut self,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int {
                BPMDetect_decimate(self, dest, src, numsamples)
            }
            #[inline]
            pub unsafe fn calcEnvelope(
                &mut self,
                samples: *mut root::soundtouch::SAMPLETYPE,
                numsamples: ::core::ffi::c_int,
            ) {
                BPMDetect_calcEnvelope(self, samples, numsamples)
            }
            #[inline]
            pub unsafe fn removeBias(&mut self) {
                BPMDetect_removeBias(self)
            }
            #[inline]
            pub unsafe fn updateBeatPos(&mut self, process_samples: ::core::ffi::c_int) {
                BPMDetect_updateBeatPos(self, process_samples)
            }
            #[inline]
            pub unsafe fn inputSamples(
                &mut self,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: ::core::ffi::c_int,
            ) {
                BPMDetect_inputSamples(self, samples, numSamples)
            }
            #[inline]
            pub unsafe fn getBpm(&mut self) -> f32 {
                BPMDetect_getBpm(self)
            }
            #[inline]
            pub unsafe fn getBeats(
                &mut self,
                pos: *mut f32,
                strength: *mut f32,
                max_num: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int {
                BPMDetect_getBeats(self, pos, strength, max_num)
            }
            #[inline]
            pub unsafe fn new(
                numChannels: ::core::ffi::c_int,
                sampleRate: ::core::ffi::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                BPMDetect_BPMDetect(__bindgen_tmp.as_mut_ptr(), numChannels, sampleRate);
                __bindgen_tmp.assume_init()
            }
        }
        unsafe extern "C" {
            #[doc = " Destructor."]
            #[link_name = "\u{1}??1BPMDetect@soundtouch@@UEAA@XZ"]
            pub fn BPMDetect_BPMDetect_destructor(this: *mut root::soundtouch::BPMDetect);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SoundTouch {
            pub _base: root::soundtouch::FIFOProcessor,
            #[doc = " Rate transposer class instance"]
            pub pRateTransposer: *mut root::RateTransposer,
            #[doc = " Time-stretch class instance"]
            pub pTDStretch: *mut root::TDStretch,
            #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
            pub virtualRate: f64,
            #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
            pub virtualTempo: f64,
            #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
            pub virtualPitch: f64,
            #[doc = " Flag: Has sample rate been set?"]
            pub bSrateSet: bool,
            #[doc = " Accumulator for how many samples in total will be expected as output vs. samples put in,\n considering current processing settings."]
            pub samplesExpectedOut: f64,
            #[doc = " Accumulator for how many samples in total have been read out from the processing so far"]
            pub samplesOutput: ::core::ffi::c_long,
            #[doc = " Number of channels"]
            pub channels: root::uint,
            #[doc = " Effective 'rate' value calculated from 'virtualRate', 'virtualTempo' and 'virtualPitch'"]
            pub rate: f64,
            #[doc = " Effective 'tempo' value calculated from 'virtualRate', 'virtualTempo' and 'virtualPitch'"]
            pub tempo: f64,
        }
        unsafe extern "C" {
            #[doc = " Get SoundTouch library version string"]
            #[link_name = "\u{1}?getVersionString@SoundTouch@soundtouch@@SAPEBDXZ"]
            pub fn SoundTouch_getVersionString() -> *const ::core::ffi::c_char;
        }
        unsafe extern "C" {
            #[doc = " Get SoundTouch library version Id"]
            #[link_name = "\u{1}?getVersionId@SoundTouch@soundtouch@@SAIXZ"]
            pub fn SoundTouch_getVersionId() -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Sets new rate control value. Normal rate = 1.0, smaller values\n represent slower rate, larger faster rates."]
            #[link_name = "\u{1}?setRate@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setRate(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        unsafe extern "C" {
            #[doc = " Sets new tempo control value. Normal tempo = 1.0, smaller values\n represent slower tempo, larger faster tempo."]
            #[link_name = "\u{1}?setTempo@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setTempo(this: *mut root::soundtouch::SoundTouch, newTempo: f64);
        }
        unsafe extern "C" {
            #[doc = " Sets new rate control value as a difference in percents compared\n to the original rate (-50 .. +100 %)"]
            #[link_name = "\u{1}?setRateChange@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setRateChange(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        unsafe extern "C" {
            #[doc = " Sets new tempo control value as a difference in percents compared\n to the original tempo (-50 .. +100 %)"]
            #[link_name = "\u{1}?setTempoChange@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setTempoChange(
                this: *mut root::soundtouch::SoundTouch,
                newTempo: f64,
            );
        }
        unsafe extern "C" {
            #[doc = " Sets new pitch control value. Original pitch = 1.0, smaller values\n represent lower pitches, larger values higher pitch."]
            #[link_name = "\u{1}?setPitch@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitch(this: *mut root::soundtouch::SoundTouch, newPitch: f64);
        }
        unsafe extern "C" {
            #[doc = " Sets pitch change in octaves compared to the original pitch\n (-1.00 .. +1.00)"]
            #[link_name = "\u{1}?setPitchOctaves@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitchOctaves(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        unsafe extern "C" {
            #[doc = " Sets pitch change in semi-tones compared to the original pitch\n (-12 .. +12)"]
            #[link_name = "\u{1}?setPitchSemiTones@SoundTouch@soundtouch@@QEAAXH@Z"]
            pub fn SoundTouch_setPitchSemiTones(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: ::core::ffi::c_int,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}?setPitchSemiTones@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitchSemiTones1(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        unsafe extern "C" {
            #[doc = " Sets the number of channels, 1 = mono, 2 = stereo"]
            #[link_name = "\u{1}?setChannels@SoundTouch@soundtouch@@QEAAXI@Z"]
            pub fn SoundTouch_setChannels(
                this: *mut root::soundtouch::SoundTouch,
                numChannels: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Sets sample rate."]
            #[link_name = "\u{1}?setSampleRate@SoundTouch@soundtouch@@QEAAXI@Z"]
            pub fn SoundTouch_setSampleRate(
                this: *mut root::soundtouch::SoundTouch,
                srate: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Get ratio between input and output audio durations, useful for calculating\n processed output duration: if you'll process a stream of N samples, then\n you can expect to get out N * getInputOutputSampleRatio() samples.\n\n This ratio will give accurate target duration ratio for a full audio track,\n given that the the whole track is processed with same processing parameters.\n\n If this ratio is applied to calculate intermediate offsets inside a processing\n stream, then this ratio is approximate and can deviate +- some tens of milliseconds\n from ideal offset, yet by end of the audio stream the duration ratio will become\n exact.\n\n Example: if processing with parameters \"-tempo=15 -pitch=-3\", the function\n will return value 0.8695652... Now, if processing an audio stream whose duration\n is exactly one million audio samples, then you can expect the processed\n output duration  be 0.869565 * 1000000 = 869565 samples."]
            #[link_name = "\u{1}?getInputOutputSampleRatio@SoundTouch@soundtouch@@QEAANXZ"]
            pub fn SoundTouch_getInputOutputSampleRatio(
                this: *mut root::soundtouch::SoundTouch,
            ) -> f64;
        }
        unsafe extern "C" {
            #[doc = " Note: This function is meant for extracting the last samples of a sound\n stream. This function may introduce additional blank samples in the end\n of the sound stream, and thus it's not recommended to call this function\n in the middle of a sound stream."]
            #[link_name = "\u{1}?flush@SoundTouch@soundtouch@@QEAAXXZ"]
            pub fn SoundTouch_flush(this: *mut root::soundtouch::SoundTouch);
        }
        unsafe extern "C" {
            #[doc = " Changes a setting controlling the processing system behaviour. See the\n 'SETTING_...' defines for available setting ID's.\n\n \\return 'true' if the setting was successfully changed"]
            #[link_name = "\u{1}?setSetting@SoundTouch@soundtouch@@QEAA_NHH@Z"]
            pub fn SoundTouch_setSetting(
                this: *mut root::soundtouch::SoundTouch,
                settingId: ::core::ffi::c_int,
                value: ::core::ffi::c_int,
            ) -> bool;
        }
        unsafe extern "C" {
            #[doc = " Reads a setting controlling the processing system behaviour. See the\n 'SETTING_...' defines for available setting ID's.\n\n \\return the setting value."]
            #[link_name = "\u{1}?getSetting@SoundTouch@soundtouch@@QEBAHH@Z"]
            pub fn SoundTouch_getSetting(
                this: *const root::soundtouch::SoundTouch,
                settingId: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}??0SoundTouch@soundtouch@@QEAA@XZ"]
            pub fn SoundTouch_SoundTouch(this: *mut root::soundtouch::SoundTouch);
        }
        impl SoundTouch {
            #[inline]
            pub unsafe fn getVersionString() -> *const ::core::ffi::c_char {
                SoundTouch_getVersionString()
            }
            #[inline]
            pub unsafe fn getVersionId() -> root::uint {
                SoundTouch_getVersionId()
            }
            #[inline]
            pub unsafe fn setRate(&mut self, newRate: f64) {
                SoundTouch_setRate(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempo(&mut self, newTempo: f64) {
                SoundTouch_setTempo(self, newTempo)
            }
            #[inline]
            pub unsafe fn setRateChange(&mut self, newRate: f64) {
                SoundTouch_setRateChange(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempoChange(&mut self, newTempo: f64) {
                SoundTouch_setTempoChange(self, newTempo)
            }
            #[inline]
            pub unsafe fn setPitch(&mut self, newPitch: f64) {
                SoundTouch_setPitch(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchOctaves(&mut self, newPitch: f64) {
                SoundTouch_setPitchOctaves(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones(&mut self, newPitch: ::core::ffi::c_int) {
                SoundTouch_setPitchSemiTones(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones1(&mut self, newPitch: f64) {
                SoundTouch_setPitchSemiTones1(self, newPitch)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: root::uint) {
                SoundTouch_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn setSampleRate(&mut self, srate: root::uint) {
                SoundTouch_setSampleRate(self, srate)
            }
            #[inline]
            pub unsafe fn getInputOutputSampleRatio(&mut self) -> f64 {
                SoundTouch_getInputOutputSampleRatio(self)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                SoundTouch_flush(self)
            }
            #[inline]
            pub unsafe fn setSetting(
                &mut self,
                settingId: ::core::ffi::c_int,
                value: ::core::ffi::c_int,
            ) -> bool {
                SoundTouch_setSetting(self, settingId, value)
            }
            #[inline]
            pub unsafe fn getSetting(&self, settingId: ::core::ffi::c_int) -> ::core::ffi::c_int {
                SoundTouch_getSetting(self, settingId)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                SoundTouch_SoundTouch(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}??1SoundTouch@soundtouch@@UEAA@XZ"]
            pub fn SoundTouch_SoundTouch_destructor(this: *mut root::soundtouch::SoundTouch);
        }
        unsafe extern "C" {
            #[doc = " Adds 'numSamples' pcs of samples from the 'samples' memory position into\n the input of the object. Notice that sample rate _has_to_ be set before\n calling this function, otherwise throws a runtime_error exception."]
            #[link_name = "\u{1}?putSamples@SoundTouch@soundtouch@@UEAAXPEBMI@Z"]
            pub fn SoundTouch_putSamples(
                this: *mut ::core::ffi::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        unsafe extern "C" {
            #[doc = " Output samples from beginning of the sample buffer. Copies requested samples to\n output buffer and removes them from the sample buffer. If there are less than\n 'numsample' samples in the buffer, returns all that available.\n\n \\return Number of samples returned."]
            #[link_name = "\u{1}?receiveSamples@SoundTouch@soundtouch@@UEAAIPEAMI@Z"]
            pub fn SoundTouch_receiveSamples(
                this: *mut ::core::ffi::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Adjusts book-keeping so that given number of samples are removed from beginning of the\n sample buffer without copying them anywhere.\n\n Used to reduce the number of samples in the buffer when accessing the sample buffer directly\n with 'ptrBegin' function."]
            #[link_name = "\u{1}?receiveSamples@SoundTouch@soundtouch@@UEAAII@Z"]
            pub fn SoundTouch_receiveSamples1(
                this: *mut ::core::ffi::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        unsafe extern "C" {
            #[doc = " Clears all the samples in the object's output and internal processing\n buffers."]
            #[link_name = "\u{1}?clear@SoundTouch@soundtouch@@UEAAXXZ"]
            pub fn SoundTouch_clear(this: *mut ::core::ffi::c_void);
        }
        unsafe extern "C" {
            #[doc = " Returns number of samples currently unprocessed."]
            #[link_name = "\u{1}?numUnprocessedSamples@SoundTouch@soundtouch@@UEBAIXZ"]
            pub fn SoundTouch_numUnprocessedSamples(this: *mut ::core::ffi::c_void) -> root::uint;
        }
    }
    #[doc = " Rate transposer class instance"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RateTransposer {
        pub _address: u8,
    }
    #[doc = " Time-stretch class instance"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct TDStretch {
        pub _address: u8,
    }
}
